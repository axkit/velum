package velum

import (
	"testing"

	"github.com/axkit/velum/reflectx"
)

func Test_IsValueGeneratedByDB(t *testing.T) {
	tests := []struct {
		name   string
		column Column
		want   bool
	}{
		{
			name:   "Value generated by SerialFieleType",
			column: Column{ValueGenerationMethod: SerialFieleType},
			want:   true,
		},
		{
			name:   "Value generated by UuidFileType",
			column: Column{ValueGenerationMethod: UuidFileType},
			want:   true,
		},
		{
			name:   "Value generated by FriendlySequence",
			column: Column{ValueGenerationMethod: FriendlySequence},
			want:   true,
		},
		{
			name:   "Value generated by CustomSequece",
			column: Column{ValueGenerationMethod: CustomSequece},
			want:   true,
		},
		{
			name:   "Value not generated by database",
			column: Column{ValueGenerationMethod: NoSequence},
			want:   false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.column.IsValueGeneratedByDB(); got != tt.want {
				t.Errorf("IsValueGeneratedByDB() = %v, want %v", got, tt.want)
			}
		})
	}
}
func Test_IsSystem(t *testing.T) {
	tests := []struct {
		name   string
		column Column
		want   bool
	}{
		{
			name: "Column with system scope",
			column: Column{
				Tag: reflectx.TagPairs{scopeTagKey: {string(DeleteScope)}},
			},
			want: true,
		},
		{
			name: "Column without system scope",
			column: Column{
				Tag: reflectx.TagPairs{scopeTagKey: {"user"}},
			},
			want: false,
		},
		{
			name: "Column with multiple scopes including system",
			column: Column{
				Tag: reflectx.TagPairs{scopeTagKey: {"user", string(UpdateScope)}},
			},
			want: true,
		},
		{
			name: "Column with no scopes",
			column: Column{
				Tag: reflectx.TagPairs{},
			},
			want: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.column.IsSystem(); got != tt.want {
				t.Errorf("IsSystem() = %v, want %v", got, tt.want)
			}
		})
	}
}
func Test_InsertArgument(t *testing.T) {
	tests := []struct {
		name           string
		genMethod      ColumnValueGenMethod
		valueGenerator string
		regularParam   string
		want           string
	}{
		{
			name:      "tag option 'serial' returns DEFAULT",
			genMethod: SerialFieleType,
			want:      "DEFAULT",
		},
		{
			name:      "tag option 'uuid' returns gen_random_uuid()",
			genMethod: UuidFileType,
			want:      "gen_random_uuid()",
		},
		{
			name:         "noseq returns $1",
			genMethod:    NoSequence,
			regularParam: "$1",
			want:         "$1",
		},
		{
			name:           "tag option 'seq=custom_seq' returns nextval with custom_seq",
			genMethod:      CustomSequece,
			valueGenerator: "custom_seq",
			want:           "nextval('custom_seq')",
		},
		{
			name:           "FriendlySequence returns nextval with 'friendly_sequence'",
			genMethod:      FriendlySequence,
			valueGenerator: "friendly_sequence",
			want:           "nextval('friendly_sequence')",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := InsertArgument(tt.genMethod, tt.valueGenerator, tt.regularParam); got != tt.want {
				t.Errorf("InsertArgument() = %v, want %v", got, tt.want)
			}
		})
	}
}
func Test_colValueGenMethod(t *testing.T) {
	tests := []struct {
		name       string
		genOptVal  string
		wantMethod ColumnValueGenMethod
		wantValue  string
	}{
		{
			name:       "SerialFieleType returns DEFAULT",
			genOptVal:  string(SerialFieleType),
			wantMethod: SerialFieleType,
			wantValue:  "DEFAULT",
		},
		{
			name:       "UuidFileType returns gen_random_uuid()",
			genOptVal:  string(UuidFileType),
			wantMethod: UuidFileType,
			wantValue:  "gen_random_uuid()",
		},
		{
			name:       "NoSequence returns empty value",
			genOptVal:  string(NoSequence),
			wantMethod: NoSequence,
			wantValue:  "",
		},
		{
			name:       "Empty string returns NoSequence with empty value",
			genOptVal:  "",
			wantMethod: NoSequence,
			wantValue:  "",
		},
		{
			name:       "Custom sequence returns CustomSequece with genOptVal",
			genOptVal:  "custom_sequence",
			wantMethod: CustomSequece,
			wantValue:  "custom_sequence",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gotMethod, gotValue := colValueGenMethod(tt.genOptVal)
			if gotMethod != tt.wantMethod || gotValue != tt.wantValue {
				t.Errorf("colValueGenMethod(%q) = (%v, %q), want (%v, %q)", tt.genOptVal, gotMethod, gotValue, tt.wantMethod, tt.wantValue)
			}
		})
	}
}
